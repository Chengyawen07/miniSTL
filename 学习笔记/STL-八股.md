### **1. 什么是STL？包含什么组件？**

STL（Standard Template Library）是C++的标准模板库，提供通用的数据结构和算法。包含以下组件：

- **容器（Containers）**：如 `vector`、`list`、`map`、`set` 等
- **算法（Algorithms）**：如 `sort`、`find`、`accumulate` 等
- **迭代器（Iterators）**：用于遍历容器，如 `begin()` 和 `end()`
- **函数对象（Functors）**：自定义行为的可调用对象，如 `greater<int>`
- **适配器（Adapters）**：如 `stack`、`queue`、`priority_queue`
- **Allocator:** 内存分配

------



### **2. 解释C++中的迭代器和容器**

- **迭代器（Iterator）**：用于访问容器元素的抽象指针 （Pointer access to container）
  - **输入迭代器（Input Iterator）**：`istream_iterator`
  - **输出迭代器（Output Iterator）**：`ostream_iterator`
  - **前向迭代器（Forward Iterator）**：**`unordered_map` 只支持前向迭代器**，因为哈希结构不能反向遍历。
  - **双向迭代器（Bidirectional Iterator）**：**`list` 只支持双向迭代器**，因为它是链表结构，不支持随机访问，但可以前后移动。
  - **随机访问迭代器（Random Access Iterator）**：`vector`、`array`
    - **`vector` 和 `array` 支持随机访问迭代器**，因为它们的内存是连续的，<u>可以通过 `index` 随机访问元素。</u>
- **容器（Container）**：STL提供的存储数据的结构，分为：
  - **序列容器**：`vector`、`deque`、`list`
  - **关联容器**：`map`、`set`、`unordered_map`、`unordered_set`
  - **适配器**：`stack`、`queue`、`priority_queue`



### 迭代器基本语法：vector<int>::iterator it;

常见迭代器操作：

- `it++` / `++it` → 移动到下一个元素
- `it--` / `--it` → 移动到前一个元素（仅限双向或随机访问迭代器）
- `*it` → 访问当前元素
- `it + n` / `it - n` → 仅适用于随机访问迭代器，如 `vector::iterator`

```c++
#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> vec = {1, 2, 3, 4, 5};
    
    // 迭代器定义
    vector<int>::iterator it;
    
    // 遍历容器
    for (it = vec.begin(); it != vec.end(); ++it) {
        cout << *it << " ";  // 访问当前元素
    }
    
    return 0;
}
```



### **3. 容器的优缺点**

| 容器                              | 数据结构    | 优点                                           | 缺点                                                         |
| --------------------------------- | ----------- | ---------------------------------------------- | ------------------------------------------------------------ |
| `vector`                          | 数组        | 内存连续，C兼容，支持随机访问 `O(1)`，节省空间 | 插入/删除代价大，扩容需要 `O(n)` 复制，动态扩容会有2倍内存开销 |
| `list`                            | 链表        | 插入/删除 `O(1)`，合并两个 `list` 也是 `O(1)`  | 不支持随机访问 `O(n)`，内存占用高（指针额外开销）            |
| `deque`                           | 数组 + 链表 | 支持高效随机访问 `O(1)`，两端插入删除 `O(1)`   | 内存占用比 `vector` 高                                       |
| `map` / `set`                     | **红黑树**  | **自动排序**，插入/查找 `O(log n)`             | 内存占用较大，插入速度比 `unordered_map` 慢                  |
| `multimap` / `multiset`           | **红黑树**  | **允许重复元素**，查找 `O(log n)`              | 和 `map` 相同，额外管理重复键的开销                          |
| `unordered_map` / `unordered_set` | **哈希表**  | 插入/查找 `O(1) 平均`                          | 无序，最坏情况下 `O(n)`（哈希冲突），占用更多内存            |



### **4. `resize` 和 `reserve` 的区别**

- **`resize(n)`**：
  - **改变容器的大小，并且创建对象：**改变 `vector` 的**大小**，如果 `n > size()`，会默认填充新元素；如果 `n < size()`，会删除多余元素。
  - 可能会引发 **元素构造/析构** 操作。
  - 影响 `size()` 和 `capacity()`（可能重新分配内存）。
- **`reserve(n)`**：
  - **容器预留空间，但并不真正创建元素对象，**在创建对象之前，不能引用容器内的元素，因此当加入新的元素时，需要用 push_back()/insert()函数。
  - **不会初始化新元素**，也不会影响 `size()`，只是减少未来扩容的次数。
  - **避免频繁的内存分配，提高性能**。

**总结**：

- `resize(n)` **改变大小**，可能会初始化新元素。
- `reserve(n)` **改变容量**，但不影响 `size()`，只提前申请内存。

------



### **5. STL 中 `vector` 的实现**

STL中的vector是封装了动态数组的顺序容器，核心结构如下：

1. **存储结构**：vector 维护一个 **连续的动态数组**，包含：
   - `pointer to first element`（数据指针）
   - `size`（当前元素个数）
   - `capacity`（已分配空间大小）
2. **vector可以根据需要自动扩大容器的大小**
   - 当 `size() == capacity()` 时，需要 **扩容**，通常是 **2 倍增长**（`capacity *= 2`）。
   - 重新申请更大的内存，并将旧数据拷贝过去（`std::move` 或 `memcpy`）。
3. **核心操作**：
   - 插入（push_back）：
     - 如果有足够容量，直接插入 `O(1)`。
     - 否则，触发扩容 `O(n)`（重新分配内存并拷贝旧数据）。
     - 在原来空间不够存储新值时，每次调用push_back方法都会重新分配新的空间以满足新数据的添加操作。如果在程序中频繁进行这种操作，还是比较消耗性能的。
   - 删除（pop_back）：
     - 直接减少 `size`，不释放内存 `O(1)`。
   - 随机访问：
     - 直接通过索引 `O(1)` 访问，因数据连续存储。
4. **优化策略**：
   - **使用 `reserve(n)` 预分配内存，减少扩容次数。**
   - 使用 `shrink_to_fit()` 释放多余的 `capacity`。



### **6. `vector` 使用注意点及 `push_back()` 对性能的影响**

- **问题**：`push_back()` 可能导致频繁扩容，影响性能。
- 原因：
  - `vector` 采用 **动态数组**，当 `size() == capacity()` 时，需要 **重新分配 2 倍的内存** 并拷贝旧数据。
  - 这个过程涉及 **内存分配、数据拷贝、释放旧空间**，导致 **时间和空间开销增加**。
- 优化建议：
  - **如果已知元素个数，先用 `reserve(n)` 预分配空间，避免频繁扩容。**
  - **如果插入操作很多（特别是中间位置插入），考虑 `list`**，因其插入 `O(1)` 而 `vector` 插入 `O(n)`。

------



### **7. `push_back()` vs. `emplace_back()`**

| 方法                        | 操作                           | 构造方式                   | 性能                          |
| --------------------------- | ------------------------------ | -------------------------- | ----------------------------- |
| `push_back(obj)`            | 复制/移动 `obj`                | 需要调用 **拷贝/移动构造** | **可能有额外的拷贝/移动开销** |
| `push_back(std::move(obj))` | 移动 `obj`                     | 调用 **移动构造**          | **减少拷贝，但仍有对象创建**  |
| `emplace_back(args...)`     | **直接在 `vector` 内存中构造** | **避免拷贝/移动构造**      | **最快，直接构造元素**        |

**区别**：

- `push_back(obj)` **需要创建一个对象并拷贝/移动到 `vector`**。
- `emplace_back(args...)` **直接在 `vector` 内存中构造对象，避免拷贝/移动**，适用于复杂对象，提高性能。

**总结**：

- <u>**如果已经有对象，使用 `push_back(std::move(obj))` 以减少拷贝。**</u>
- **如果要直接创建对象，优先用 `emplace_back()`，更高效！**



### **8. STL 中 `sort()` 的实现**

#### **IntroSort 机制（`std::sort()` 的实现）**

1. **大数据量时，使用** **快速排序（QuickSort）** → `O(n log n)`
2. **当子区间 ≤16 个元素时，切换为** **插入排序（InsertionSort）** → `O(n)`
3. **如果递归深度超过 `log(n)`（防止最坏情况 `O(n^2)`），改用** **堆排序（HeapSort）** → `O(n log n)`

- **结论**
  - **`std::sort()` 主要基于 **快速排序（QuickSort），但在特定情况下会使用插入排序和堆排序。
  - **标准库用的是 `IntroSort`，比单纯的 QuickSort 更稳健，不会退化成 `O(n^2)`。**

**代码示例**：

```cpp
#include <algorithm>
#include <vector>
#include <iostream>

int main() {
    std::vector<int> v = {5, 3, 8, 6, 2, 7, 4, 1};
    std::sort(v.begin(), v.end());  // 使用 IntroSort
    for (int n : v) std::cout << n << " ";
    return 0;
}
```

**总结**：

- `std::sort()` 采用 **IntroSort**，结合快速排序、插入排序和堆排序。
- 避免递归过深导致栈溢出，**当递归深度超过 `log(n)` 时自动切换为堆排序**。
- **小数据量（≤16）时，使用插入排序，提高局部性缓存性能**。

------



### **9. STL 容器线程不安全的解决方案**

**问题**：

- **`vector` 线程不安全**，多线程同时 `push_back()` 或者 **读写并发** 可能导致 **迭代器失效、core dump**。
- **内存重新分配**：当 `vector` 触发扩容，可能导致**读线程访问已释放的内存**。

**解决方案**：

1. **使用 `std::mutex` 互斥锁**：

   - 适用于 **多读多写** 场景，但性能较差。

   - 代码示例：

     ```cpp
     #include <vector>
     #include <thread>
     #include <mutex>
     #include <iostream>
     
     std::vector<int> vec;
     std::mutex mtx;
     
     void thread_safe_push(int val) {
         std::lock_guard<std::mutex> lock(mtx);
         vec.push_back(val);
     }
     ```

2. **使用读写锁 `std::shared_mutex`（C++17）**：

   - **多读少写场景**，提高性能。

   - 代码示例：

     ```cpp
     #include <shared_mutex>
     
     std::shared_mutex rw_lock;
     
     void read_vector() {
         std::shared_lock<std::shared_mutex> lock(rw_lock); // 读锁
         // 读取 vector
     }
     
     void write_vector(int val) {
         std::unique_lock<std::shared_mutex> lock(rw_lock); // 写锁
         vec.push_back(val);
     }
     ```

3. **使用 `std::atomic` 或 `lock-free` 容器**：

   - 避免锁竞争，提高性能，如 `std::atomic<int>` 或 **无锁数据结构（Lock-Free Queue）**。

4. **预分配内存，避免 `push_back()` 触发扩容**：

   - 在 **开始并发访问前**，用 `reserve()` 固定 `vector` 大小，避免 **动态扩容**。

   - 代码示例：

     ```cpp
     std::vector<int> vec;
     vec.reserve(1000);  // 预分配 1000 个元素
     ```

**总结**：

- **`std::mutex`** 适用于 **多写并发**（但性能较低）。
- **`std::shared_mutex`（C++17）** 适用于 **多读少写** 场景，性能更优。
- **`reserve(n)` 预分配 vector 容量，避免 `push_back()` 触发扩容，减少锁的需求**。
- **如果需要高性能无锁结构，可以考虑 `lock-free queue`**（如 `boost::lockfree::queue`）。



### **10. 哪些容器可以使用 `std::sort()`？**

- **不能使用 `sort()` 的容器**：
  - 关联容器（map, set, multimap, multiset）
    - 这些容器 **底层是红黑树（RB-Tree），本身是有序的**，无需 `sort()`。
  - 适配器容器（stack, queue, priority_queue）
    - 这些容器**只有特定的出入口**，无法直接访问内部元素进行排序。
- **可以使用 `sort()` 的容器**：
  - `vector`、`deque`
    - 这两种容器**支持随机访问迭代器**，可以使用 `std::sort()`。

PS补充：什么是红黑树

- **红黑树（Red-Black Tree, RB-Tree）** 是一种 **自平衡二叉搜索树（BST）**，用于保证 **插入、删除、查找** 都能在 `O(log n)` 时间复杂度内完成。

### **红黑树 vs. 普通二叉搜索树（BST）**

| **对比项**    | **普通二叉搜索树（BST）**           | **红黑树（RB-Tree）**         |
| ------------- | ----------------------------------- | ----------------------------- |
| **结构**      | 只有大小关系，没有颜色约束          | 额外维护红/黑颜色，确保平衡   |
| **平衡性**    | 可能退化成链表（`O(n)`）            | **自平衡，保证 `O(log n)`**   |
| **插入/删除** | 可能导致不平衡，最坏 `O(n)`         | **自动调整，保证 `O(log n)`** |
| **搜索效率**  | **最坏情况 `O(n)`**（如果变成链表） | **始终 `O(log n)`**           |

普通二叉树可能会退化成 **链表（极端情况）**，而红黑树始终保持 **平衡**，保证所有操作 `O(log n)` 复杂度。

**总结**：

- **`vector` 和 `deque` 可以使用 `std::sort()`。**
- **关联容器（`map`、`set`）自带排序，不需要 `sort()`。**
- **`stack`、`queue`、`priority_queue` 结构受限，无法使用 `sort()`。**

------



### **11. 为什么小于 16 的区间使用插入排序？**

- 插入排序在小数据量下效率高，原因如下：
  1. 减少递归调用
     - 快速排序是递归算法，小区间继续递归反而浪费时间。
  2. **插入排序对于几乎有序的数据效率更高**（接近 `O(n)`）。
  3. 缓存友好
     - 快速排序会导致大量 **数据交换**，而插入排序只需少量移动，**更符合 CPU 缓存优化**。

**总结**：

- 小区间（≤16）时，**插入排序更快、更省资源**，避免快速排序的递归开销。

------



### **12. 为什么不直接用堆排序，而要用快速排序？**

堆排序的时间复杂度是 `O(n log n)`，但**实际性能比快速排序差**，主要原因：

**总结**

- 快速排序更快，因为：
  1. **更好的缓存局部性**，CPU 访问更快。
  2. **常数因子更小**，数据交换更少。
  3. **分区操作更高效**，分治方式能更快地处理数据。
- 堆排序用来避免最坏情况：
  - <u>**递归深度过深时，改用堆排序避免 `O(n^2)` 退化问题。**</u>

**最终结论**：

- **大部分情况用快速排序**，它比堆排序 **实际运行更快**。
- **遇到最坏情况（递归过深）时改用堆排序**，保证 `O(n log n)`。



### **13. `vector` / `list` / `deque` 的区别与联系**

#### **联系**

- **都是序列式容器**，内部元素**不一定有序**，但都可以使用 `std::sort()` 进行排序。
- **都支持迭代器**，可以用 `begin()` / `end()` 遍历元素。

#### **区别**

比较可从下面三个方面展开：

1. 内部实现
2. 性能访问
3. 使用场景

| **对比项**       | **`vector`**                                                 | **`list`**                                           | **`deque`**                                                  |
| ---------------- | ------------------------------------------------------------ | ---------------------------------------------------- | ------------------------------------------------------------ |
| **适用场景**     | **随机访问快**，适用于读取多、插入/删除少的场景。 缺点：头部插入会很慢，因为后面的元素都需要移动。 **适用于尾部插入+访问** | **插入/删除快**，适用于插入/删除多、随机访问少的场景 | **两端操作快**，适用于两端插入/删除多的场景                  |
| **存储方式**     | <u>**连续内存**，类似数组，扩容时申请新空间并拷贝数据</u>    | **非连续内存**，使用双向链表存储，指针连接各节点     | **<u>分块存储</u>**，`_Map`（中央控制器）管理多个存储块，逻辑上连续 |
| **访问方式**     | **支持 `[]` 下标操作**，随机访问 `O(1)`                      | **不支持 `[]`，只能用迭代器**，随机访问 `O(n)`       | **支持 `[]` 下标操作**，但访问速度略慢于 `vector`            |
| **插入/删除**    | **中间插入/删除 `O(n)`**，`push_back()` `O(1)`               | **插入/删除 `O(1)`**（但必须移动指针）               | **两端 `push_front()` 和 `push_back()` `O(1)`**              |
| **迭代器稳定性** | **可能失效**（扩容时重新分配内存）                           | **稳定**（增删元素不影响其他迭代器）                 | **可能失效**（结构调整时）                                   |

PS 补充： `begin()` / `end()` 遍历元素 需要满足什么条件？

✅ 容器支持迭代器（Iterator）： **适用于 STL 容器（`vector`, `list`, `map` 等）**
✅ **不能用于 `stack` / `queue`**
✅ **遍历时不能修改 `vector` 或 `deque`（会导致迭代器失效）**
✅ **`end()` 不能解引用**
✅ **迭代器类型必须匹配容器存储类型**

**总结：**

- **频繁随机访问** → 选择 `vector`
- **频繁插入/删除** → 选择 `list`
- **两端操作频繁** → 选择 `deque`

------



### **14. `stack` 和 `queue` 适配器为什么不用 `vector` 实现？**

- **`stack` 和 `queue` 底层通常使用 `list` 或 `deque`，而不是 `vector`**。
- 原因：
  1. **`vector` 不能高效地 `push_front()`，因为它只能在尾部插入**，无法高效实现 `queue`（FIFO 队列）或 `stack`（LIFO 栈）。
  2. **`vector` 扩容时需要重新分配内存并拷贝数据**，影响 `stack` 和 `queue` 的性能。
  3. **`deque` 适合 `queue`（两端高效操作）**，**`list` 适合 `stack`（插入/删除快）**。

**结论：**

- **`stack` 常用 `list` 或 `deque`**，因为它只需要 `push` 和 `pop`，不需要随机访问。
- **`queue` 适合 `deque`**，因为它需要高效的 `push_front()` 和 `push_back()`。

------



### **15. 为什么关联容器的插入效率比序列容器高？**

- **关联容器（`map`、`set`）底层是** **红黑树（RB-Tree）**，<u>**插入/删除只需要调整指针，不涉及数据拷贝**。</u>
- 序列容器（`vector`、`deque`）在插入时可能需要移动数据：
  - `vector`：插入会导致 **所有后续元素移动**，`O(n)`。
  - <u>`deque`：类似 `vector`，但**可能涉及多个块的调整**，</u>也可能导致 `O(n)`。
  - `list`：双向链表，只调整指针，`O(1)`。
  - **`map/set`：使用红黑树，插入时只调整指针 `O(log n)`，比 `vector` 的 `O(n)` 快**。

**总结**：

- **`map/set` 插入效率高**，因为只是修改指针，不需要移动数据。
- **`vector` 插入效率低**，因为插入时可能会移动大量数据。
- **`list` 插入也很快**，因为链表的插入只涉及指针调整。

------



### **16. 为什么 `vector` 的插入操作可能导致迭代器失效？**

**原因：**

1. **扩容（Reallocation）**：
   - <u>`vector` 扩容时，**会申请更大内存（2 倍），然后将旧元素拷贝到新内存，并释放原来的空间**。</u>
   - <u>**所有指向旧内存的迭代器失效！**</u>
   - **`begin()`、`end()`、`last element` 的迭代器都失效**。
2. **插入（Insert）导致 `end()` 迭代器失效**：
   - `vector` 的 `end()` 迭代器始终指向 **尾后元素**，插入新元素后，`end()` 位置变化，原来的 `end()` 迭代器失效。
3. **删除（Erase）导致部分迭代器失效**：
   - **被删除元素及其后的所有元素迭代器都会失效**，因为 `vector` **必须移动剩余元素**。

------



### **17. 如何避免 `vector` 迭代器失效？**

- **提前 `reserve(n)` 预分配内存，减少扩容次数：**

  ```cpp
  std::vector<int> v;
  v.reserve(1000);  // 预分配 1000 个元素，避免扩容
  ```

- 使用 `list` 代替 `vector`，如果频繁插入删除：

  ```cpp
  std::list<int>::iterator it;
  ```

- **插入元素后，不要继续使用旧的迭代器，重新获取 `begin()` / `end()` 迭代器**。

------

### **总结**

- `vector`、`list`、`deque` 适用于不同场景：
  - `vector` → 随机访问快，插入删除慢。
  - `list` → 插入删除快，随机访问慢。
  - `deque` → 两端插入删除快，支持下标访问。
- **`stack` / `queue` 适配器一般用 `list` 或 `deque`，避免 `vector` 的扩容问题**。
- **`map` / `set` 插入比 `vector` 快，因为它们不需要移动元素，只调整指针**。
- <u>**`vector` 迭代器失效主要因扩容和元素移动，预分配 `reserve(n)` 可以减少影响**。</u>



### **18. `unordered_map` 和 `map` 的实现机制及性能差异**

#### **实现机制**

- **`map`**：底层实现是 **红黑树（RB-Tree）**，有序存储，插入/删除/查找复杂度 `O(log N)`。
- **`unordered_map`**：底层实现是 **哈希表（Hash Table）**，无序存储，插入/删除/查找平均复杂度 `O(1)`，最坏 `O(N)`（哈希冲突）。

#### **性能对比**

| 对比项        | `map`（红黑树）                       | `unordered_map`（哈希表）    |
| ------------- | ------------------------------------- | ---------------------------- |
| **有序性**    | 有序（按键排序）                      | 无序                         |
| **插入/删除** | `O(log N)`                            | `O(1)`（最坏 `O(N)`）        |
| **查找**      | `O(log N)`                            | `O(1)`（最坏 `O(N)`）        |
| **内存占用**  | 较高（存储额外的父/子指针、颜色信息） | 较低（哈希桶）               |
| **适用场景**  | 需要**排序**、范围查询、迭代顺序      | 需要**快速查找**，不关心顺序 |

#### **适用场景**

- **`map`**：适用于 **少量查询但需要顺序访问的场景**（如字典、排序数据）。
- **`unordered_map`**：适用于 **大量查询且无序的场景**（如哈希索引、缓存系统）。
- **当 `unordered_map` 出现严重哈希冲突（导致最坏 `O(N)`），性能可能比 `map` 还低！**

------



### **19. `set` 和 `map` 的区别与联系**

#### **联系**

1. **都是标准关联容器，底层都是红黑树**（`set` / `map`）。
2. **插入、删除、查找时间复杂度 `O(log N)`**。
3. **`set` 和 `map` 元素会自动排序：**
   - `set`：按值自动排序。
   - `map`：按 **key** 自动排序。

#### **区别**

| **对比项**   | **`set`**                         | **`map`**                                                    |
| ------------ | --------------------------------- | ------------------------------------------------------------ |
| **存储内容** | 只存 `key`（不允许重复）          | 存 `key-value` 对                                            |
| **重复元素** | 不允许（`multiset` 允许）         | `key` 不允许重复，`value` 可重复（`multimap` 允许 `key` 也重复） |
| **修改元素** | 不能修改已有元素（需删除再插入）  | `key` 不能修改，但 `value` 可修改                            |
| **适用场景** | 适用于 **唯一集合查询**（如去重） | 适用于 **键值对存储**（如字典）                              |

------



### **20. `set`、`map` 和 `vector` 的插入复杂度**

| **容器类型**                          | **插入复杂度**                   |
| ------------------------------------- | -------------------------------- |
| **`set` / `map`**                     | `O(log N)`（红黑树插入）         |
| **`unordered_set` / `unordered_map`** | `O(1)`（最坏 `O(N)`）            |
| **`vector`**                          | 末尾插入 `O(1)`，其他位置 `O(N)` |

- **`vector` 插入慢**，因为中间插入需要移动元素或扩容。
- **`unordered_map` 插入快**，但哈希冲突时最坏 `O(N)`。
- **`set` / `map` 适用于排序需求**，但插入 `O(log N)`。

------



### **21. 不允许遍历的容器（不提供迭代器）**

| **容器**                   | **原因**                             |
| -------------------------- | ------------------------------------ |
| **`queue`**                | **只能访问头部**，无法遍历所有元素   |
| **`stack`**                | **只能访问栈顶**，不支持随机访问     |
| **`priority_queue`**（堆） | **元素按优先级排序**，不支持顺序遍历 |

**总结**

- **`queue` 和 `stack` 只允许 FIFO/LIFO 访问，不能遍历。**
- **`priority_queue` 依赖堆结构，不能直接遍历所有元素。**

PS补充：

#### **哪些 STL 容器有 `operator[]`？**

| **STL 容器**            | **是否支持 `operator[]`？** | **原因**                            |
| ----------------------- | --------------------------- | ----------------------------------- |
| `vector`                | ✅ **支持**                  | 连续存储，支持随机访问              |
| `deque`                 | ✅ **支持**                  | 分块存储，但支持随机访问            |
| `array`                 | ✅ **支持**                  | 固定大小数组，支持随机访问          |
| `string`                | ✅ **支持**                  | 允许 `s[i]` 访问字符                |
| `map`                   | ✅ **支持**                  | `m[key]` 访问 `value`，不存在会创建 |
| `unordered_map`         | ✅ **支持**                  | `m[key]` 访问 `value`，无序存储     |
| `list`                  | ❌ **不支持**                | 不是连续存储，不能随机访问          |
| `set` / `unordered_set` | ❌ **不支持**                | 只有 `key`，不支持索引访问          |
| `queue` / `stack`       | ❌ **不支持**                | 只能按 FIFO/LIFO 访问               |

#### **总结**

✅ **STL 容器（`vector`, `deque`, `map` 等）已经内置 `operator[]`，可以直接用！**
✅ **`list`, `set`, `queue`, `stack` 没有 `operator[]`，因为它们不支持随机访问。**
✅ **自己定义的类如果想支持 `[]`，就要手动实现 `operator[]`。**



#### 1.  **`list` 访问方式**

- **`list`**：不能随机访问，只能用 `advance()` 移动迭代器。

| **访问方式**              | **代码示例**                                                 | **适用场景**      |
| ------------------------- | ------------------------------------------------------------ | ----------------- |
| **遍历（迭代器）**        | `for (auto it = lst.begin(); it != lst.end(); ++it) std::cout << *it;` | 访问所有元素      |
| **访问首元素**            | `lst.front()`                                                | 获取头部          |
| **访问尾元素**            | `lst.back()`                                                 | 获取尾部          |
| **手动 `advance()` 访问** | `std::advance(it, 3);`                                       | 访问第 `n` 个元素 |

#### **2. “访问” vs. “随机访问”**

| **类型**     | **是否支持 `operator[]`** | **访问方式**             | **复杂度**   |
| ------------ | ------------------------- | ------------------------ | ------------ |
| **`vector`** | ✅ 支持 `v[i]`             | `[]` / `at()` / 迭代器   | **O(1)**     |
| **`deque`**  | ✅ 支持 `d[i]`             | `[]` / `at()` / 迭代器   | **O(1)**     |
| **`list`**   | ❌ 不支持 `l[i]`           | `advance(it, n)`         | **O(n)**     |
| **`map`**    | ✅ 支持 `m[key]`           | `[]` / `at()` / `find()` | **O(log n)** |
| **`set`**    | ❌ 不支持 `s[i]`           | `find()` / 迭代器        | **O(log n)** |



#### ✅ 3. **访问（Access）和查找（Find）的区别**

| **概念**           | **作用**               | **适用容器**                                                 | **常用方法**                                          |
| ------------------ | ---------------------- | ------------------------------------------------------------ | ----------------------------------------------------- |
| **访问（Access）** | **获取指定位置的元素** | `vector`, `deque`, `list`, `map`, `set`                      | `operator[]`, `at()`, `front()`, `back()`, 迭代器     |
| **查找（Find）**   | **找到特定值的元素**   | `map`, `set`, `unordered_map`, `unordered_set`, `vector`, `list` | `find()`, `count()`, `lower_bound()`, `upper_bound()` |

### **总结**

✅ **访问（Access） = 取值（已知位置），查找（Find） = 找值（未知位置）**
✅ **访问常用 `[]`, `at()`, `front()`, `back()`，适用于 `vector`, `deque`, `map`**
✅ **查找常用 `find()`, `count()`, `lower_bound()`，适用于 `vector`, `list`, `set`, `map`**
✅ **哈希表 `unordered_map` 查找比 `map` 更快 (`O(1)` vs `O(log n)`)**



### **22. STL 容器在哪些情况下迭代器会失效？**

#### **1. `vector`**

- **扩容（`push_back()`）**
  - **`end()` 迭代器必定失效**，因为新空间分配后，旧地址无效。
  - **如果 `capacity()` 变大，所有迭代器都会失效**，因为数据被重新分配。
- **删除（`erase()` / `pop_back()`）**
  - **被删除的元素及其后面的元素的迭代器全部失效**（因为 `vector` 需要移动后续元素）。
  - **`erase()` 返回下一个有效的迭代器**，推荐用 `iter = v.erase(iter)` 代替 `++iter`。

------

#### **2. `list`**

- **`list` 迭代器相对稳定**，**删除（`erase()`）时只有被删除的元素迭代器失效**，其他迭代器不受影响。
- **插入（`insert()`）不会影响其他迭代器。**
- **适合频繁插入/删除的场景。**

------

#### **3. `deque`**

- **首尾插入 `push_front()` / `push_back()` 不影响已有迭代器**。
- **中间插入/删除导致所有迭代器失效**（因为 `deque` 可能重新分配存储块）。
- **如果 `deque` 重新分配内存（扩容），所有迭代器都会失效**。

------



### **23. 迭代器删除元素时的影响**

**区别：序列式容器（`vector`, `deque`）VS 关联式容器（`map`, `set`）**

#### **1. `map` / `set`（红黑树，关联容器）**

- <u>**删除某个元素，只有该元素的迭代器失效**，其他迭代器不受影响（因为底层是指针结构）。</u>

- 正确删除方法：

  ```cpp
  std::set<int> s = {1, 2, 3, 4, 5};
  auto it = s.begin();
  while (it != s.end()) {
      if (*it == 3) it = s.erase(it);  // `erase()` 返回下一个有效迭代器
      else ++it;
  }
  ```

------

#### **2. `vector` / `deque`（序列式容器）**

- <u>**删除后所有后续元素会向前移动，导致后续迭代器失效。**</u>

- `erase()` 返回下一个有效迭代器，推荐用 `iter = v.erase(iter)`：

  ```cpp
  std::vector<int> v = {1, 2, 3, 4, 5};
  auto it = v.begin();
  while (it != v.end()) {
      if (*it == 3) it = v.erase(it);  // 直接更新 `it`
      else ++it;
  }
  ```

- 错误做法：

  ```cpp
  v.erase(it);  // ❌ it 失效，不能再 ++it
  ```

------

#### **3. `list`（双向链表）**

- <u>**删除某个元素，只有被删除的元素迭代器失效，其他迭代器仍然有效**。</u>

- `erase()` 返回下一个有效迭代器，可以直接使用：

  ```cpp
  std::list<int> lst = {1, 2, 3, 4, 5};
  auto it = lst.begin();
  while (it != lst.end()) {
      if (*it == 3) it = lst.erase(it);
      else ++it;
  }
  ```

------



### **24. 哈希函数的构造方法**

#### **1. 什么是哈希表？**

哈希表（Hash Table）是一种 **键值对（key-value）存储结构**，可以在 **平均 `O(1)` 时间** 内完成 **插入、删除和查找**。

🔹 **基本思路**：

1. **使用哈希函数（Hash Function）** 计算 `key` 的哈希值，确定存储位置（桶）。
2. **将 `key-value` 存入哈希表** 的某个位置（哈希桶）。
3. <u>**查找时，用相同的哈希函数计算哈希值**，直接访问存储位置。</u>

#### **2. 哈希表的结构**

哈希表通常由 **数组（Bucket Array）+ 哈希函数** 组成，主要有以下部分：

| **组件**                      | **作用**                                                |
| ----------------------------- | ------------------------------------------------------- |
| **哈希函数（Hash Function）** | 计算 `key` 的哈希值，映射到哈希表                       |
| **哈希桶（Bucket）**          | 存放 `key-value` 对                                     |
| **解决哈希冲突的策略**        | 处理不同 `key` 映射到同一个桶的情况                     |
| **负载因子（Load Factor）**   | 控制哈希表的扩容，通常 `load factor > 0.75` 触发 rehash |



创建哈希函数的方法：

1. **除留余数法**
   - **最常用的方法**：H(key) = key % p  // p 取一个质数（比如 101, 503）



### **STL `unordered_map`（哈希表）的实现**

- **底层是 `hashtable`（哈希表），使用开链法解决哈希冲突**。
- **当哈希桶的大小超过 `8` 时，自动转为红黑树存储，提高最坏情况查找效率。**
- **插入/删除/查找平均 `O(1)`，最坏 `O(N)`（哈希冲突严重时）。**

------



### **25. Hash 表的冲突解决方法**

#### **1. 开链法（Separate Chaining）**

- 每个哈希桶存一个链表，发生冲突时，新元素插入链表：

  ```cpp
  std::unordered_map<int, std::string> m;
  ```
  
- **优点**：简单，适用于负载因子较小的情况。

- **缺点**：如果链表太长，最坏情况变为 `O(N)`。

------

#### **2. 开放地址法（Open Addressing）**

- **冲突时寻找下一个空位存放元素（线性探测/二次探测/双重哈希）**
- **优点**：适用于负载因子较小的哈希表。
- **缺点**：删除元素可能会影响查询，可能会导致更多哈希冲突。

------

#### **3. 再哈希法（Rehashing）**

- **当哈希表过满时，扩容并重新计算所有元素的哈希值。**
- **`unordered_map` 在扩容时，会执行 `rehash()` 操作**。

------



### **总结**

✅ **STL `vector`、`list`、`deque` 迭代器失效的情况不同**：

- `vector`：**扩容后所有迭代器失效，删除后所有后续元素迭代器失效**。
- `list`：**删除的元素迭代器失效，其他不变**。
- `deque`：**首尾插入无影响，中间插入/删除使所有迭代器失效**。

✅ **迭代器删除元素时：**

- **`vector`/`deque` 需要 `iter = erase(iter)`**
- **`list`/`set`/`map` 只影响当前迭代器**

✅ **`unordered_map` 用哈希表，哈希冲突用开链法（桶）解决**。



### 26. map 中[ ] 和 find count的区别？

 **`map` 中 `operator[]`、`find()` 和 `count()` 的区别**

| **操作**     | **功能**            | **如果 key 不存在？**          | **返回值**                                                | **时间复杂度** |
| ------------ | ------------------- | ------------------------------ | --------------------------------------------------------- | -------------- |
| `operator[]` | 访问 `key` 对应的值 | **创建一个默认值并插入 `map`** | `value` 的引用                                            | `O(log n)`     |
| `find(key)`  | 查找 `key`          | **不会插入新元素**             | 迭代器（找到返回指向 `key` 的迭代器，没找到返回 `end()`） | `O(log n)`     |
| `count(key)` | 统计 `key` 出现次数 | **不会插入新元素**             | `0`（不存在） 或 `1`（存在）                              | `O(log n)`     |

------

### 

### 27. 所有容器的底层实现

| **容器**               | **底层实现**                           |
| ---------------------- | -------------------------------------- |
| **vector**             | 动态数组（连续存储）                   |
| **deque**              | 分段数组 + 双端队列                    |
| **list**               | 双向链表                               |
| **array**              | 固定大小数组                           |
| **stack**              | 适配器（底层通常用 deque 或 list）     |
| **queue**              | 适配器（底层通常用 deque）             |
| **priority_queue**     | 适配器（底层用堆，默认用 vector 实现） |
| **map**                | 红黑树（RB-Tree）                      |
| **multimap**           | 红黑树（RB-Tree）                      |
| **set**                | 红黑树（RB-Tree）                      |
| **multiset**           | 红黑树（RB-Tree）                      |
| **unordered_map**      | 哈希表（开链法）                       |
| **unordered_multimap** | 哈希表（开链法）                       |
| **unordered_set**      | 哈希表（开链法）                       |
| **unordered_multiset** | 哈希表（开链法）                       |









